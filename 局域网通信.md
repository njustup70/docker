# 远程开发
支持同一局域网下的数据传输，可以通过樱花内网穿透将不同局域网打通可参考[远程ssh](https://github.com/njustup70/vision_doc/blob/master/%E4%B8%89%E7%A7%8D%E8%BF%9C%E7%A8%8B%E9%93%BE%E6%8E%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%92%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.md)
有关fastdds的问题可参考[文档](https://docs.ros.org/en/humble/Tutorials/Advanced/Discovery-Server/Discovery-Server.html#fast-dds-discovery-server-v2)

##  1.普通但够用
首先得在ros2中启动一个 ID 为 0、端口 11811（默认端口）的发现服务器，并监听所有可用的接口

    fastdds discovery --server-id 0 --ip-address 127.0.0.1 --port 11811

新建终端设置环境变量

    export ROS_DISCOVERY_SERVER=127.0.0.1:11811

启动侦听器节点

    ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener_discovery_server

可在不同电脑上新建终端启动talker节点

    export ROS_DISCOVERY_SERVER=127.0.0.1:11811
    ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker_discovery_server

执行Discovery Server
    ros2 run demo_nodes_cpp listener --ros-args --remap __node:=simple_listener

验证一切是否正常运行
    ros2 run demo_nodes_cpp talker --ros-args --remap __node:=simple_talker

这样有一个问题就是"无法查看话题的名称及个数等等",所以我们采用第二种方法。


## 2.比较可行
通过配置超级客户端可以解决看不到话题的问题

这是super_client配置文件
    <dds>
        <profiles xmlns="http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles">
            <participant profile_name="super_client_profile" is_default_profile="true">
                <rtps>
                    <builtin>
                        <discovery_config>
                            <discoveryProtocol>SUPER_CLIENT</discoveryProtocol>
                            <discoveryServersList>
                                <RemoteServer prefix="44.53.00.5f.45.50.52.4f.53.49.4d.41">
                                    <metatrafficUnicastLocatorList>
                                        <locator>
                                            <udpv4>
                                                <address>127.0.0.1</address>
                                                <port>11811</port>
                                            </udpv4>
                                        </locator>
                                    </metatrafficUnicastLocatorList>
                                </RemoteServer>
                            </discoveryServersList>
                        </discovery_config>
                    </builtin>
                </rtps>
            </participant>
        </profiles>
    </dds>

这设置成一个单独的文件，复制其位置

然后是一样的操作，除了客户端变成了super，还要添加其位置信息

    fastdds discovery -i 0 -l 127.0.0.1 -p 11811

新建终端
    export ROS_DISCOVERY_SERVER="127.0.0.1:11811"

    ros2 run demo_nodes_cpp listener --ros-args --remap __node:=listener

新建终端
    export ROS_DISCOVERY_SERVER="127.0.0.1:11811"

    ros2 run demo_nodes_cpp talker --ros-args --remap __node:=talker

新建终端
    export FASTRTPS_DEFAULT_PROFILES_FILE=super_client_configuration_file.xml
（类似如此  export FASTRTPS_DEFAULT_PROFILES_FILE=path/to/super_client_config.xml）

然后关闭再打开守护进程就可以查看了

    ros2 daemon stop
    ros2 daemon start
    ros2 topic list
    ros2 node info /talker
    ros2 topic info /chatter
    ros2 topic echo /chatter


然后就可以传输数据（图片啥的）


最后是一段可能有用的python文件

    import rclpy
    from rclpy.node import Node
    from sensor_msgs.msg import Image
    from cv_bridge import CvBridge
    import cv2

    class VideoPublisher(Node):
        def __init__(self):
            super().__init__('video_publisher')
            self.publisher_ = self.create_publisher(Image, 'video_frames', 10)
            self.timer = self.create_timer(0.03, self.timer_callback)  # 30 FPS
            self.cap = cv2.VideoCapture('2.mp4')  # 替换为视频文件路径
            self.bridge = CvBridge()
            if not self.cap.isOpened():
                self.get_logger().error('Failed to open video file.')
                rclpy.shutdown()

        def timer_callback(self):
            ret, frame = self.cap.read()
            if not ret:
                self.get_logger().info('End of video.')
                rclpy.shutdown()
                return
            # 转换 OpenCV 图像为 ROS 图像消息
            msg = self.bridge.cv2_to_imgmsg(frame, encoding='bgr8')
            self.publisher_.publish(msg)
            self.get_logger().info('Published frame.')

    def main(args=None):
        rclpy.init(args=args)
        node = VideoPublisher()
        try:
            rclpy.spin(node)
        except KeyboardInterrupt:
            pass
        finally:
            node.cap.release()
            node.destroy_node()
            rclpy.shutdown()

    if __name__ == '__main__':
        main()



